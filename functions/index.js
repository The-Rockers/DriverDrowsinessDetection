// ?id={googleUser ID}&type={fileType} // API request query format
// https://us-central1-antisomnus-381222.cloudfunctions.net/exportUserData?id=KlbEZkEFuxZqbY3qPijHdrROeks1&type=csv // production example
// http://127.0.0.1:5001/antisomnus-381222/us-central1/exportUserData?id=KlbEZkEFuxZqbY3qPijHdrROeks1&type=csv // local

// The Cloud Functions for Firebase SDK to create Cloud Functions and set up triggers.
const functions = require('firebase-functions');

const os = require('os');
const fs = require('fs'); 
const url = require('url');

const path = require('path');
const reader = require('xlsx');
const parquet = require('parquetjs');

// The Firebase Admin SDK to access Firestore.
const admin = require('firebase-admin');
admin.initializeApp({
  // NEED TO REMEMBER TO CHANGE EMULATION BUCKET TO PRODUCTION BUCKET!!!
  //storageBucket: "gs://antisomnus-381222.appspot.com/", // emulation bucket
  keyFilename: "./service-account.json",
  storageBucket: "gs://antisomnus-bucket", // Deployment bucket
});

let writeToBucket = function(filePath, userId, fileType){ // Works BUT must initialize app to the RIGHT bucket for each environment

  if(filePath == null){
    console.log("The filepath was null!");
    return;
  }

  // writes file to temporary cloud function instance storage and uploads to bucket

  var type;

  switch(fileType){
    case "CSV":
      type = "csv";
      break;

    case "XLS":
      type = "xlsx";
      break;

    case "PRQ":
      type = "parquet"; // parquet file not currently supported
      break;
  }

  const storage = admin.storage();
  let destination = `dash_reports/${userId}/report.${type}`;
  let url = [];

  storage.bucket()
  .upload( filePath, { destination } )
  .then( () => {console.log("sucessfully uploaded file to bucket"); /*fs.unlinkSync(filePath)*/} ) // DO NOT DELETE FILE. does not execute synchronously
  .catch(err => console.error('ERROR inside upload: ', err) );

  let expireTime = new Date();

  return new Promise( function (resolve, reject){
    storage.bucket().file(destination).getSignedUrl({
      action: 'read',
      expires: expireTime.setMinutes(expireTime.getMinutes() + 5), // will be valid for 5 minutes
    }).then(signedUrls => {
      console.log("Returning URL from writeToBucket: " + signedUrls[0]); // Works in production environment
      resolve(signedUrls[0]);
    });
  });

  //return url[0]; // have to wait until signed URL is generated by the promise

}

let writeToCSV = function(data, userId){

  let tempPath = path.join(os.tmpdir(), `${userId}.csv`);
  let outputString = `Month, Week, Day 1, Day 2, Day 3, Day 4, Day 5, Day 6, Day 7 \n`;

  //console.log("DATA: " + data);

  let months = Object.keys(data); // months
  //console.log("months: " + months);

  months.forEach((month) => {
    let weeks = Object.keys(data[month]); // weeksStarts
    //console.log("weeks: " + weeks); 

      weeks.forEach((week) => {
        let values = data[month][week]
        let temp = [];

        for(let i = 0; i < 7; i++){
          if(!values[i]){
            temp.push(0);
          }
          else{
            temp.push(values[i]);
          }
        }

        outputString += `${month},${week},${temp}\n`;
        //console.log("data: " + values);
      });
  });

  try {
      //fs.appendFileSync(`./antisomnus_data${userId}.csv`, outputString); // works on local but not on GCP

      console.log("trying to write to file");
      fs.writeFileSync(tempPath, outputString); // write file INSTEAD of appending it
      //fs.appendFileSync(tempPath, outputString); // temporarily stop writing to the file
      console.log("written to file");
      return tempPath;
      
  } catch (err) {
      console.error(err);
  }

  //return `./antisomnus_data${userId}.csv`; // returns the file path to the new file // works on local but not GCP
  console.log("Returning filepath from writetocsv: " + tempPath);
  return null; // moving this code into the block with fs.appendFileSync (above) works BUT it does not write to file. Moving it down here writes to file but does not sent it to storage?

}

let writeToExcel = function(data, userId){ // needs to be properly tested before being deployed

  // it expects an array of objects of this format
  // let testObj = {Month: "1-1-23", Week: "1-15-23", Day1: 5, Day2: 2, Day3: 6, Day7: 9}
  // JSON string should be in format '{"Month":"1-1-23","Week":"1-15-23","Day1":5,"Day2":2,"Day3":6,"Day7":9}'
  // run JSON parse on the String

  let tempPath = path.join(os.tmpdir(), `${userId}.xlsx`); // location and filename where file will be written to

  // data will be passed in a JSONObject
  var outputString = ``;
  var tempJSONArray = [];
  var tempJSONObject;
  var months = Object.keys(data); // returns the keys to the JSON object (which are months)

  months.forEach((month) => {
    let weeks = Object.keys(data[month]); // weeksStarts

      weeks.forEach((week) => {
        outputString = `{"Month": "${month}", "Week": "${week}",`;

        let values = data[month][week]
        let temp = [];

        for(let i = 0; i < 7; i++){
          if(!values[i]){
            outputString += `"Day${i+1}":${0}`;
          }
          else{
            outputString += `"Day${i+1}":${values[i]}`;
          }
          if(i === 6){
            outputString += ``;
          }
          else{
            outputString += `,`;
          }
          
        }

        outputString += `}\n`; 

        try{
        tempJSONObject = JSON.parse(outputString); // fails at this line
        } catch (e) {
          console.log("error: " + e);
        }
        tempJSONArray.push(JSON.parse(outputString));

        // '{"Month":"1-1-23","Week":"1-15-23","Day1":5,"Day2":2,"Day3":6,"Day7":9}'
        // Parse that object and push to teampJSONArray

      });
  });

  //tempJSONArray.push(data);

  const ws = reader.utils.json_to_sheet(tempJSONArray); // Very nifty method!
  const wb = reader.utils.book_new();

  reader.utils.book_append_sheet(wb,ws,"data");
  reader.writeFile(wb, tempPath);

  return tempPath;

}

let writeToParquet = async function(data, userId){

  var schema = new parquet.ParquetSchema({
    Month: { type: 'UTF8' },
    Week: { type: 'UTF8' },
    Day1: { type: 'INT64' },
    Day2: { type: 'INT64' },
    Day3: { type: 'INT64' },
    Day4: { type: 'INT64' },
    Day5: { type: 'INT64' },
    Day6: { type: 'INT64' },
    Day7: { type: 'INT64' },
  });

  let tempPath = path.join(os.tmpdir(), `${userId}.parquet`)
  let writer = await parquet.ParquetWriter.openFile(schema, tempPath);

  var outputString = ``;
  var tempJSONArray = [];
  var tempJSONObject;
  var months = Object.keys(data); // returns the keys to the JSON object (which are months)

  months.forEach((month) => {
    let weeks = Object.keys(data[month]); // weeksStarts

      weeks.forEach((week) => {
        outputString = `{"Month": "${month}", "Week": "${week}",`;

        let values = data[month][week]

        for(let i = 0; i < 7; i++){
          if(!values[i]){
            outputString += `"Day${i+1}":${0}`;
          }
          else{
            outputString += `"Day${i+1}":${values[i]}`;
          }
          if(i === 6){
            outputString += ``;
          }
          else{
            outputString += `,`;
          }
          
        }

        outputString += `}\n`; 

        try{
        tempJSONObject = JSON.parse(outputString);
        } catch (e) {
          console.log("error: " + e);
        }

        tempJSONArray.push(JSON.parse(outputString));

      });
  });


  for(let i = 0; i < tempJSONArray.length; i++){
   try{
    await writer.appendRow(tempJSONArray[i]);
   } catch (e){
    console.log("Error: " + e);
   }
  }

  await writer.close();
  return tempPath;

}

exports.exportUserData = functions.https.onRequest(async (req, res) => { // returns JSON object of user's data in firestore for specified userID

    res.header('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Origin', '*'); // set access control so all sites can call API without receiving CORS errors

    // firebase emulator test ID: pDElawFtvufKVcfItl6m
    let monthsDataKeys; // A list of keys for the doc.data() objects returns
    let monthsString = ``;
    let monthsDataString = ``;
    let monthCount = -1; // keep index for months

    const queryData = url.parse(req.url, true).query;

    console.log("Number of params in query: " + Object.keys(queryData).length);

    if(Object.keys(queryData).length != 2){
      return res.send("Error: Incorrect number of params in query. Expected format \"?id={userID}&type={fileType}\"");
    }

    const userId = queryData.id;
    let fileType = queryData.type.toUpperCase();
  
    console.log("User ID in request query: " + userId);
    console.log("File type in request query: " + fileType);

    if(!(fileType == "CSV" || fileType == "PRQ" || fileType == "XLS")){
      return res.send("Error: Invalid file type entered. Supported types are CSV, PRQ, or XLS");
    }

    if(!userId || userId == ""){
      return res.send("Error: no User is Present");
    }

    await admin.firestore().collection('users').doc(userId).collection('data').get().then(async snapshot => { // retrieve firestore data and format as JSON response

      let dayIDs = [];
      let dayDrowsiness = Array(snapshot.docs.length).fill(0);
      let dayDrowsinessSum = 0;

      for(let i = 0; i < snapshot.docs.length; i++){ // docs is each day

        dayIDs[i] = snapshot.docs[i].id;
        let daySessionIds = [];

        await admin.firestore().collection('users').doc(userId).collection('data').doc(dayIDs[i]).collection('driver_sessions').get().then( async snapshot1 => { // docs is each session

          for(let j = 0; j < snapshot1.docs.length; j++){
            daySessionIds[j] = snapshot1.docs[j].id;

            await admin.firestore().collection('users').doc(userId).collection('data').doc(dayIDs[i]).collection('driver_sessions').doc(daySessionIds[j]).get().then( async snapshot2 => { // session data
              //console.log(snapshot2.data()["drowsiness_summary"]["drowsy"]);
              dayDrowsiness[i] += snapshot2.data()["drowsiness_summary"]["drowsy"];
            });

          }

        });
      }

      //console.log(dayIDs);
      //console.log(dayDrowsiness);

      let JSONObject = {};
      let monthKeys = [];

      for(let i = 0; i < dayIDs.length; i++){

        let temp = new Date(dayIDs[i]);
        temp.setDate(temp.getDate() - (temp.getDate()) + 1); // set date to beginning of month
      
        if(!JSONObject[temp.toISOString().substring(0,10)]){
          JSONObject[temp.toISOString().substring(0,10)] = {};
          monthKeys.push(temp.toISOString().substring(0,10));
        }

      }

      for(let i = 0; i < monthKeys.length; i++){

        if(Object.keys(JSONObject[monthKeys[i]]).length == 0){ // if no weeks, populate with corresponding weeks

          let startOfMonth = new Date(monthKeys[i]);
          let startOfMonthDay = startOfMonth.getDay();
          let startOfMonthMonth = startOfMonth.getMonth();
          let tempDate = new Date(monthKeys[i]);
          let weekSize = 0;

          for(let j = 0; j < 35; j++){ // move tempDate to the end of the month

            if(tempDate.getMonth() != startOfMonthMonth){ // if jump to next month, break
              break;
            }

            tempDate.setDate(tempDate.getDate() + 1); // increment by one day

          }

          //tempDate.setDate(tempDate.getDate() - 1); // decrement by one day
          //weekSize++;

          for(let j = 0; j < 35; j++){ // Move backwards to record week size for each week

            tempDate.setDate(tempDate.getDate() - 1); // decrement by one day
            weekSize++;

            if(tempDate.getMonth() != startOfMonthMonth){ // if moved to new month
              break;
            }

            if(tempDate.getDay() == startOfMonthDay){
              JSONObject[monthKeys[i]][tempDate.toISOString().substring(0,10)] = new Array(weekSize).fill(0);
              weekSize = 0;
            }

          }

        }

      }

      //console.log(JSONObject);

      for(let i = 0; i < dayIDs.length; i++){

        let dayIndex = 0;
        let firstOfMonthKey = "";
        let temp = new Date(dayIDs[i]);

        temp.setDate(temp.getDate() - (temp.getDate()) + 1); // set date to beginning of month

        firstOfMonthKey = temp.toISOString().substring(0,10);
        temp = new Date(dayIDs[i]);

        for(let j = 0; j < 9; j++){ // search for specific week

          if(JSONObject[firstOfMonthKey][temp.toISOString().substring(0,10)]){ // JSONObject-> firstOfMonthKey -> firstOfWeekKey. If key exists
            JSONObject[firstOfMonthKey][temp.toISOString().substring(0,10)][dayIndex] = dayDrowsiness[i];
            break; // MUST occur since week will be in JSONObject
          }
          else{
            temp.setDate(temp.getDate() - 1); // decrement by one day
            dayIndex++;
          }

        }

      }

      //console.log(JSONObject);

      var path = "";

      switch(fileType){
        case "CSV":
          path = writeToCSV(JSONObject, userId);
          break;

        case "XLS":
          path = writeToExcel(JSONObject, userId);
          break;

        case "PRQ":
          path = await writeToParquet(JSONObject, userId);
          break;
      }

      //let path = writeToExcel(JSONObject, userId); // write to excel file testing
      //let path = writeToCSV(JSONObject, userId);
        writeToBucket(path,userId, fileType).then((signedURL) => {
        console.log("Returned signed URL from writeToBucket: " + signedURL);

        let signedURLJSON = `{"url" : "${signedURL}"}`; // return signed URL as JSON
        
        res.header('Access-Control-Allow-Origin', '*');
        res.set('Access-Control-Allow-Origin', '*');
        res.send(JSON.parse(signedURLJSON));
        //res.send(`${signedURL}`);
      });

      console.log("Finished sending signed URL!");

    }).catch(reason => {
      res.send(reason);
    })

  });